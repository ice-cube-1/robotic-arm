{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home The arm runs on Python, and most of your code will be parsed just as any other Python code. The only difference is a few pre-written methods and access to the \"Barrel\" and \"Camera\" classes. The high-level movement functions provide most of the functionality that the arm offers, although there is also the option to manually control the arm via the arm class (NOTE: calling these directly will not update the web render, and there is no documentation). Visit the GitHub repo for the full source code, or see how to use some of the arm's functions .","title":"Home"},{"location":"#home","text":"The arm runs on Python, and most of your code will be parsed just as any other Python code. The only difference is a few pre-written methods and access to the \"Barrel\" and \"Camera\" classes. The high-level movement functions provide most of the functionality that the arm offers, although there is also the option to manually control the arm via the arm class (NOTE: calling these directly will not update the web render, and there is no documentation). Visit the GitHub repo for the full source code, or see how to use some of the arm's functions .","title":"Home"},{"location":"barrel/","text":"Barrel Barrels should not be manually created, but retrieving their properties is often useful. Methods self.angle: int self.distance: float The angle (in steps, so 200 per full rotation) of the stepper when the barrel is directly in the center of its vision, and the distance the barrel is away from the pivot. self.x: int self.y: int Polar to cartesian conversions of angle and distance self.gripped: bool = False Whether the barrel is currently held by the claw, in which case the position information is incorrect. self.color: str The colour of the barrel (red, yellow or blue) Return data getData(self) -> str returns the x, y and colour in a space-delimited string (used for websocket transmission)","title":"Barrel"},{"location":"barrel/#barrel","text":"Barrels should not be manually created, but retrieving their properties is often useful.","title":"Barrel"},{"location":"barrel/#methods","text":"self.angle: int self.distance: float The angle (in steps, so 200 per full rotation) of the stepper when the barrel is directly in the center of its vision, and the distance the barrel is away from the pivot. self.x: int self.y: int Polar to cartesian conversions of angle and distance self.gripped: bool = False Whether the barrel is currently held by the claw, in which case the position information is incorrect. self.color: str The colour of the barrel (red, yellow or blue)","title":"Methods"},{"location":"barrel/#return-data","text":"getData(self) -> str returns the x, y and colour in a space-delimited string (used for websocket transmission)","title":"Return data"},{"location":"camera/","text":"Camera An instance of the camera called camera has already been created. Do not attempt to re-initialise the class. Take photo camera.takePhoto(self) -> None Takes a picture and saves it to static/image.jpg. This will not update the webserver until you send a command via websocket notifying the client of the update. camera.takePhoto() await websocket.send(\"image\") This cannot be done repeatedly with very little delay as it causes read/write conflicts on the file. Distance camera.distance(self) -> tuple(float, str) This returns the distance of the nearest red, yellow or blue object and its color (this is likely a barrel if the value is reasonable, and empty space if not) Centre camera.getCentral(self) -> int Returns the number of pixels the center of the detected object is from the center (less than 100-150 generally means it is centered)","title":"Camera"},{"location":"camera/#camera","text":"An instance of the camera called camera has already been created. Do not attempt to re-initialise the class.","title":"Camera"},{"location":"camera/#take-photo","text":"camera.takePhoto(self) -> None Takes a picture and saves it to static/image.jpg. This will not update the webserver until you send a command via websocket notifying the client of the update. camera.takePhoto() await websocket.send(\"image\") This cannot be done repeatedly with very little delay as it causes read/write conflicts on the file.","title":"Take photo"},{"location":"camera/#distance","text":"camera.distance(self) -> tuple(float, str) This returns the distance of the nearest red, yellow or blue object and its color (this is likely a barrel if the value is reasonable, and empty space if not)","title":"Distance"},{"location":"camera/#centre","text":"camera.getCentral(self) -> int Returns the number of pixels the center of the detected object is from the center (less than 100-150 generally means it is centered)","title":"Centre"},{"location":"pre-done_functions/","text":"Pre-done functions Some extra points to note about using these: Any function defined must by asynchronous as the code is all run within an async function. Likewise, any of the below functions must be called with await. async def x(): await output(\"hello\") await x() These functions have extra parameters that are automatically passed in from your code. These are the arm, the websocket and the camera (scan and pickup only). Scan This scans a full 360 degrees ands adds any barrels it detects to the render. It also async def scan(barrels: list[Barrel] = []) -> list[Barrel] This works as follows: The arm moves up, giving it an unobstructed view of the ground It continuously rotates until the calculated distance to the nearest barrel is within 90 < distance < 300 (it believes a barrel to be somewhere in frame). It attempts to center on the barrel The barrel's colour and position is then added to the list of barrels, and sent back to the website via websocket This repeats until it has reached the start point, when it returns a list of all barrels detected Passing a pre-populated list of barrels will produce duplicates, so the only reccomended use of this parameter is if there is a barrel picked up at the point of scan Pickup From the list of barrels passed in, it picks up the one at index i. async def pickup(barrels: list[Barrel], i: int) -> list[Barrel] This moves the arm out of the way before rotating, then recenters on the barrel (in case accidental movement has offset the position slightly) and reaches down to pick it up. It then moves back up, and will repeat the whole proess if the barrel is still there. Drop Drops the current barrel, presuming it falls directly down and lands upright. async def drop(barrels: list[Barrel]) -> list[Barrel] This is just a wrapper for the open claw function, but deals with sending data via websocket as well. This requires the arm to currently be very close to the ground to work successfully, as the arm does not move down automatically. Move Moves the arm to the requested x (horizontal distance from pivot, mm) and y (vertical distance from pivot), without any rotation. async def move(x: float, y: float) -> None Rotate Rotates the entire arm, taking into account that it cannot continuously rotate in one direction. A full 360 degree rotation is divided into 200 steps. async def rotate(x: float, y: float) -> None Output Print statements do not work in this UI, so this is the asynchronous equivalent. These show up to the right of the code input, acting as a basic console. async def output(x: str) -> None","title":"Pre-done functions"},{"location":"pre-done_functions/#pre-done-functions","text":"Some extra points to note about using these: Any function defined must by asynchronous as the code is all run within an async function. Likewise, any of the below functions must be called with await. async def x(): await output(\"hello\") await x() These functions have extra parameters that are automatically passed in from your code. These are the arm, the websocket and the camera (scan and pickup only).","title":"Pre-done functions"},{"location":"pre-done_functions/#scan","text":"This scans a full 360 degrees ands adds any barrels it detects to the render. It also async def scan(barrels: list[Barrel] = []) -> list[Barrel] This works as follows: The arm moves up, giving it an unobstructed view of the ground It continuously rotates until the calculated distance to the nearest barrel is within 90 < distance < 300 (it believes a barrel to be somewhere in frame). It attempts to center on the barrel The barrel's colour and position is then added to the list of barrels, and sent back to the website via websocket This repeats until it has reached the start point, when it returns a list of all barrels detected Passing a pre-populated list of barrels will produce duplicates, so the only reccomended use of this parameter is if there is a barrel picked up at the point of scan","title":"Scan"},{"location":"pre-done_functions/#pickup","text":"From the list of barrels passed in, it picks up the one at index i. async def pickup(barrels: list[Barrel], i: int) -> list[Barrel] This moves the arm out of the way before rotating, then recenters on the barrel (in case accidental movement has offset the position slightly) and reaches down to pick it up. It then moves back up, and will repeat the whole proess if the barrel is still there.","title":"Pickup"},{"location":"pre-done_functions/#drop","text":"Drops the current barrel, presuming it falls directly down and lands upright. async def drop(barrels: list[Barrel]) -> list[Barrel] This is just a wrapper for the open claw function, but deals with sending data via websocket as well. This requires the arm to currently be very close to the ground to work successfully, as the arm does not move down automatically.","title":"Drop"},{"location":"pre-done_functions/#move","text":"Moves the arm to the requested x (horizontal distance from pivot, mm) and y (vertical distance from pivot), without any rotation. async def move(x: float, y: float) -> None","title":"Move"},{"location":"pre-done_functions/#rotate","text":"Rotates the entire arm, taking into account that it cannot continuously rotate in one direction. A full 360 degree rotation is divided into 200 steps. async def rotate(x: float, y: float) -> None","title":"Rotate"},{"location":"pre-done_functions/#output","text":"Print statements do not work in this UI, so this is the asynchronous equivalent. These show up to the right of the code input, acting as a basic console. async def output(x: str) -> None","title":"Output"}]}